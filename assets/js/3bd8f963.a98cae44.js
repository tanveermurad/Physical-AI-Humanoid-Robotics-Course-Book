"use strict";(globalThis.webpackChunkmy_book=globalThis.webpackChunkmy_book||[]).push([[594],{339:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"part1-fundamentals-of-robotics/kinematics","title":"Kinematics","description":"Kinematics in robotics is like understanding the robot\'s \\"anatomy\\" and how its body moves, without worrying about the muscles (forces) that make it move. It\'s the study of motion purely from a geometric perspective, focusing on the position, velocity, and acceleration of robot parts.","source":"@site/docs/part1-fundamentals-of-robotics/kinematics.md","sourceDirName":"part1-fundamentals-of-robotics","slug":"/part1-fundamentals-of-robotics/kinematics","permalink":"/Physical-AI-Humanoid-Robotics-Course-Book/docs/part1-fundamentals-of-robotics/kinematics","draft":false,"unlisted":false,"editUrl":"https://github.com/tanveermurad/Physical-AI-Humanoid-Robotics-Course-Book/tree/main/my-book/docs/part1-fundamentals-of-robotics/kinematics.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Introduction to Physical AI and Humanoid Robotics","permalink":"/Physical-AI-Humanoid-Robotics-Course-Book/docs/intro"},"next":{"title":"Dynamics","permalink":"/Physical-AI-Humanoid-Robotics-Course-Book/docs/part1-fundamentals-of-robotics/dynamics"}}');var s=i(4848),o=i(8453);const a={sidebar_position:1},r="Kinematics",l={},c=[{value:"Forward Kinematics (FK)",id:"forward-kinematics-fk",level:2},{value:"How it Works:",id:"how-it-works",level:3},{value:"Inverse Kinematics (IK)",id:"inverse-kinematics-ik",level:2},{value:"Challenges of IK:",id:"challenges-of-ik",level:3},{value:"Solution Approaches:",id:"solution-approaches",level:3},{value:"The Jacobian Matrix",id:"the-jacobian-matrix",level:2},{value:"Uses of the Jacobian:",id:"uses-of-the-jacobian",level:3},{value:"Application in Humanoid Robots",id:"application-in-humanoid-robots",level:2}];function h(e){const n={annotation:"annotation",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",math:"math",mi:"mi",mo:"mo",mrow:"mrow",ol:"ol",p:"p",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"kinematics",children:"Kinematics"})}),"\n",(0,s.jsx)(n.p,{children:"Kinematics in robotics is like understanding the robot's \"anatomy\" and how its body moves, without worrying about the muscles (forces) that make it move. It's the study of motion purely from a geometric perspective, focusing on the position, velocity, and acceleration of robot parts."}),"\n",(0,s.jsx)(n.h2,{id:"forward-kinematics-fk",children:"Forward Kinematics (FK)"}),"\n",(0,s.jsx)(n.p,{children:'Forward Kinematics answers the question: "If I know all the joint angles, where is the robot\'s hand (end-effector) in space?"'}),"\n",(0,s.jsx)(n.p,{children:"Imagine a human arm: if you know the angle of your shoulder, elbow, and wrist joints, you can figure out exactly where your fingertip is in relation to your body."}),"\n",(0,s.jsx)(n.h3,{id:"how-it-works",children:"How it Works:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Coordinate Frames"}),": We attach a coordinate system (like an XYZ axis) to each moving part (link) of the robot, starting from its base."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Homogeneous Transformations"}),': We use special mathematical tools called "homogeneous transformation matrices." These 4x4 matrices combine both rotation (how one part is oriented relative to another) and translation (how one part is positioned relative to another) into a single package.']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Chain Multiplication"}),": To find the end-effector's position, we multiply these transformation matrices sequentially from the robot's base all the way to its end-effector."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["A popular method for systematically assigning these coordinate frames and deriving the transformation matrices is the ",(0,s.jsx)(n.strong,{children:"Denavit-Hartenberg (DH) convention"}),". It uses four parameters (",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsxs)(n.mrow,{children:[(0,s.jsx)(n.mi,{children:"d"}),(0,s.jsx)(n.mo,{separator:"true",children:","}),(0,s.jsx)(n.mi,{children:"\u03b8"}),(0,s.jsx)(n.mo,{separator:"true",children:","}),(0,s.jsx)(n.mi,{children:"r"}),(0,s.jsx)(n.mo,{separator:"true",children:","}),(0,s.jsx)(n.mi,{children:"\u03b1"})]}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"d, \\theta, r, \\alpha"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"d"}),(0,s.jsx)(n.span,{className:"mpunct",children:","}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"\u03b8"}),(0,s.jsx)(n.span,{className:"mpunct",children:","}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"r"}),(0,s.jsx)(n.span,{className:"mpunct",children:","}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.0037em"},children:"\u03b1"})]})})]}),") to describe the relationship between adjacent links, simplifying the process for any robot arm."]}),"\n",(0,s.jsx)(n.h2,{id:"inverse-kinematics-ik",children:"Inverse Kinematics (IK)"}),"\n",(0,s.jsx)(n.p,{children:'Inverse Kinematics is the opposite, and often much harder, problem: "If I want the robot\'s hand to be at a specific point in space, what should all the joint angles be?"'}),"\n",(0,s.jsx)(n.p,{children:"Think about reaching for a cup: your brain instantly calculates the complex combination of shoulder, elbow, and wrist angles needed to place your hand exactly on the cup. For robots, this is computationally intensive."}),"\n",(0,s.jsx)(n.h3,{id:"challenges-of-ik",children:"Challenges of IK:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Multiple Solutions"}),": Just like you can reach a cup with your arm bent in different ways, a robot might have several joint configurations for the same end-effector position."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"No Solution"}),': The desired position might be out of the robot\'s reach (outside its "workspace"), meaning no solution exists.']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Complexity"}),": The equations involved are often non-linear and difficult to solve directly."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"solution-approaches",children:"Solution Approaches:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Analytical Solutions"}),": For simpler robots, we can sometimes find exact, closed-form mathematical solutions. These are fast and reliable."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Numerical Solutions"}),": For complex robots, we often use iterative methods. These start with an educated guess for the joint angles and then gradually adjust them, trying to minimize the error between the current and desired end-effector position until a satisfactory solution is found."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"the-jacobian-matrix",children:"The Jacobian Matrix"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"Jacobian matrix"})," is a powerful mathematical tool in robotics. It acts as a bridge, telling us how changes in joint velocities translate into the linear and angular velocities of the robot's end-effector."]}),"\n",(0,s.jsx)(n.h3,{id:"uses-of-the-jacobian",children:"Uses of the Jacobian:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Velocity Analysis"}),": If you know how fast each joint is moving, the Jacobian helps you calculate how fast the end-effector is moving and rotating."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Singularity Analysis"}),": It helps identify \"singularities\"\u2014robot configurations where the robot loses some of its maneuverability or degrees of freedom. (e.g., an arm fully extended, where moving the elbow doesn't change the hand's height). At these points, the Jacobian's rank drops."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Inverse Kinematics"}),": In numerical IK solutions, the inverse (or pseudo-inverse) of the Jacobian is crucial for iteratively finding the required joint velocities to move the end-effector to a desired target."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"application-in-humanoid-robots",children:"Application in Humanoid Robots"}),"\n",(0,s.jsx)(n.p,{children:"Kinematics is fundamental for humanoid robots in many ways:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Path Planning"}),": Calculating the sequence of joint movements needed to navigate the robot through its environment without collisions."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Grasping and Manipulation"}),": Precisely positioning the hand to pick up objects."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Walking Gaits"}),": Defining the complex series of joint movements that allow the robot to walk and maintain balance."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Human-Robot Interaction"}),": Ensuring the robot's movements are natural and safe when interacting with humans."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Mastering kinematics is the first step towards controlling a robot's physical interactions with the world."})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>r});var t=i(6540);const s={},o=t.createContext(s);function a(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);