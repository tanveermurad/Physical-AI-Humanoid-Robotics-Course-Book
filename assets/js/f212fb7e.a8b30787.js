"use strict";(globalThis.webpackChunkmy_book=globalThis.webpackChunkmy_book||[]).push([[166],{4098:(n,e,o)=>{o.r(e),o.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"part2-ai-for-robotics/planning","title":"Planning","description":"Planning in robotics is the process by which a robot determines a sequence of actions to take to achieve a specific goal. It\'s akin to a human thinking through how to perform a task, considering obstacles, resources, and desired outcomes. Effective planning allows robots to operate autonomously, move efficiently, and interact intelligently with their surroundings.","source":"@site/docs/part2-ai-for-robotics/planning.md","sourceDirName":"part2-ai-for-robotics","slug":"/part2-ai-for-robotics/planning","permalink":"/Physical-AI-Humanoid-Robotics-Course-Book/docs/part2-ai-for-robotics/planning","draft":false,"unlisted":false,"editUrl":"https://github.com/tanveermurad/Physical-AI-Humanoid-Robotics-Course-Book/tree/main/my-book/docs/part2-ai-for-robotics/planning.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Control Systems","permalink":"/Physical-AI-Humanoid-Robotics-Course-Book/docs/part1-fundamentals-of-robotics/control-systems"},"next":{"title":"Perception","permalink":"/Physical-AI-Humanoid-Robotics-Course-Book/docs/part2-ai-for-robotics/perception"}}');var t=o(4848),a=o(8453);const s={sidebar_position:1},r="Planning",l={},c=[{value:"Motion Planning",id:"motion-planning",level:2},{value:"Configuration Space (C-space)",id:"configuration-space-c-space",level:3},{value:"Path Planning Algorithms",id:"path-planning-algorithms",level:3},{value:"Trajectory Generation",id:"trajectory-generation",level:3},{value:"Task Planning",id:"task-planning",level:2},{value:"Multi-Robot Planning",id:"multi-robot-planning",level:2},{value:"Challenges in Robot Planning",id:"challenges-in-robot-planning",level:2}];function h(n){const e={em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"planning",children:"Planning"})}),"\n",(0,t.jsx)(e.p,{children:"Planning in robotics is the process by which a robot determines a sequence of actions to take to achieve a specific goal. It's akin to a human thinking through how to perform a task, considering obstacles, resources, and desired outcomes. Effective planning allows robots to operate autonomously, move efficiently, and interact intelligently with their surroundings."}),"\n",(0,t.jsx)(e.h2,{id:"motion-planning",children:"Motion Planning"}),"\n",(0,t.jsx)(e.p,{children:"Motion planning focuses on finding a collision-free path for a robot from a starting configuration to a goal configuration."}),"\n",(0,t.jsx)(e.h3,{id:"configuration-space-c-space",children:"Configuration Space (C-space)"}),"\n",(0,t.jsxs)(e.p,{children:["To simplify collision detection, a robot is often represented in its ",(0,t.jsx)(e.strong,{children:"configuration space (C-space)"}),'. Instead of dealing with the robot\'s complex geometry in 3D, C-space represents all possible positions and orientations of the robot as a single point. Obstacles in the workspace are "grown" into C-space obstacles, allowing the robot to be treated as a point.']}),"\n",(0,t.jsx)(e.h3,{id:"path-planning-algorithms",children:"Path Planning Algorithms"}),"\n",(0,t.jsx)(e.p,{children:"Once in C-space, various algorithms can find a path:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Grid-based Algorithms (e.g., A*, Dijkstra's)"}),": These algorithms discretize the C-space into a grid and search for the shortest path between nodes. They guarantee optimal paths but can be computationally expensive for high-dimensional spaces."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Sampling-based Algorithms (e.g., RRT, PRM)"}),": For complex, high-dimensional C-spaces (common in humanoids), sampling-based methods are more practical."]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Probabilistic Roadmaps (PRM)"}),": Builds a roadmap by randomly sampling configurations in C-space, connecting collision-free samples to form a graph. Queries then involve finding a path on this graph."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Rapidly-exploring Random Trees (RRT)"}),": Explores the C-space by growing a tree from the start configuration towards randomly sampled points. It's good for quickly finding ",(0,t.jsx)(e.em,{children:"a"})," path, though not necessarily the optimal one."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"trajectory-generation",children:"Trajectory Generation"}),"\n",(0,t.jsxs)(e.p,{children:["Once a collision-free path (a sequence of configurations) is found, ",(0,t.jsx)(e.strong,{children:"trajectory generation"})," transforms this path into a smooth, time-parameterized trajectory. This involves considering the robot's dynamic constraints (e.g., joint velocity and acceleration limits) to create a physically executable movement."]}),"\n",(0,t.jsx)(e.h2,{id:"task-planning",children:"Task Planning"}),"\n",(0,t.jsx)(e.p,{children:'Task planning operates at a higher level of abstraction than motion planning. Instead of individual joint movements, it deals with a sequence of high-level actions (e.g., "pick up object A," "move to location B," "open door").'}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Symbolic AI"}),": Traditional AI methods often use symbolic representations of tasks and environments."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"PDDL (Planning Domain Definition Language)"}),": A standardized language used to define planning problems, including the available actions, their preconditions, and their effects. Planners then search for a sequence of these actions to achieve a goal."]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"multi-robot-planning",children:"Multi-Robot Planning"}),"\n",(0,t.jsx)(e.p,{children:"When multiple robots need to cooperate or share an environment, multi-robot planning becomes necessary. This involves coordinating their actions to achieve a common goal while avoiding collisions and conflicts between robots."}),"\n",(0,t.jsx)(e.h2,{id:"challenges-in-robot-planning",children:"Challenges in Robot Planning"}),"\n",(0,t.jsx)(e.p,{children:"Planning in robotics is fraught with challenges:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Computational Cost"}),": For complex robots and environments, the search space for paths and actions can be enormous, requiring significant computational resources and time."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Uncertainty"}),": Real-world environments are inherently uncertain. Sensors provide noisy data, and actuator errors can lead to deviations from the planned path. Planners need to be robust to these uncertainties."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Dynamic Environments"}),": Environments where objects or other agents are moving require continuous replanning or reactive strategies."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"High-Dimensionality"}),": Humanoid robots have many degrees of freedom, making C-space extremely complex."]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"Despite these challenges, advancements in computational power and algorithms are continuously pushing the boundaries of what robots can plan for, enabling more autonomous and intelligent robotic systems."})]})}function d(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(h,{...n})}):h(n)}},8453:(n,e,o)=>{o.d(e,{R:()=>s,x:()=>r});var i=o(6540);const t={},a=i.createContext(t);function s(n){const e=i.useContext(a);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:s(n.components),i.createElement(a.Provider,{value:e},n.children)}}}]);