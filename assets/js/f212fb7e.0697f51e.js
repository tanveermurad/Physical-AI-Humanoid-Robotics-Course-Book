"use strict";(globalThis.webpackChunkmy_book=globalThis.webpackChunkmy_book||[]).push([[4166],{4098:(n,e,o)=>{o.r(e),o.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"part2-ai-for-robotics/planning","title":"Planning","description":"If kinematics, dynamics, and control are the \\"body\\" of a robot, planning is the \\"mind.\\" Planning is the process of reasoning about a task to find a sequence of actions that will achieve a goal. It\'s about deciding what to do, whereas control is about how to do it.","source":"@site/docs/part2-ai-for-robotics/planning.md","sourceDirName":"part2-ai-for-robotics","slug":"/part2-ai-for-robotics/planning","permalink":"/Physical-AI-Humanoid-Robotics-Course-Book/docs/part2-ai-for-robotics/planning","draft":false,"unlisted":false,"editUrl":"https://github.com/tanveermurad/Physical-AI-Humanoid-Robotics-Course-Book/tree/main/my-book/docs/part2-ai-for-robotics/planning.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Control Systems","permalink":"/Physical-AI-Humanoid-Robotics-Course-Book/docs/part1-fundamentals-of-robotics/control-systems"},"next":{"title":"Perception","permalink":"/Physical-AI-Humanoid-Robotics-Course-Book/docs/part2-ai-for-robotics/perception"}}');var i=o(4848),a=o(8453);const s={sidebar_position:2},r="Planning",l={},h=[{value:"The Planning Problem",id:"the-planning-problem",level:2},{value:"Path Planning",id:"path-planning",level:2},{value:"Common Path Planning Algorithms",id:"common-path-planning-algorithms",level:3},{value:"Motion Planning",id:"motion-planning",level:2},{value:"Task and Motion Planning (TAMP)",id:"task-and-motion-planning-tamp",level:2}];function c(n){const e={em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"planning",children:"Planning"})}),"\n",(0,i.jsxs)(e.p,{children:['If kinematics, dynamics, and control are the "body" of a robot, ',(0,i.jsx)(e.strong,{children:"planning"}),' is the "mind." Planning is the process of reasoning about a task to find a sequence of actions that will achieve a goal. It\'s about deciding ',(0,i.jsx)(e.em,{children:"what"})," to do, whereas control is about ",(0,i.jsx)(e.em,{children:"how"})," to do it."]}),"\n",(0,i.jsx)(e.p,{children:"In robotics, planning problems exist at many levels of abstraction, from finding a collision-free path for the arm to move from point A to point B, to figuring out the sequence of steps required to assemble a product."}),"\n",(0,i.jsx)(e.h2,{id:"the-planning-problem",children:"The Planning Problem"}),"\n",(0,i.jsx)(e.p,{children:"A typical planning problem can be defined by:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"State Space"}),": The set of all possible configurations of the world."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Initial State"}),": The state where the robot starts."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Goal State/Condition"}),": The desired state or a condition that must be met."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Actions"}),": A set of actions the robot can take, which cause transitions between states."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Cost Function"}),": A function that assigns a cost to a sequence of actions. The goal is to find a plan with the minimum cost."]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"path-planning",children:"Path Planning"}),"\n",(0,i.jsx)(e.p,{children:"Path planning is one of the most fundamental planning problems in robotics. The goal is to find a geometrically valid path for a robot from a start to a goal configuration while avoiding collisions with obstacles."}),"\n",(0,i.jsxs)(e.p,{children:["To solve this, we often plan in the robot's ",(0,i.jsx)(e.strong,{children:"Configuration Space (C-Space)"}),'. In C-Space, the robot is represented as a single point, and all the obstacles in the real world are "grown" to represent the set of robot configurations that would result in a collision. The problem then becomes finding a path for a point in this C-Space.']}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:"https://i.imgur.com/rG4p3yG.png",alt:"C-Space diagram"})}),"\n",(0,i.jsx)(e.h3,{id:"common-path-planning-algorithms",children:"Common Path Planning Algorithms"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Grid-Based Algorithms (e.g., A*)"}),": These methods discretize the C-Space into a grid and use graph search algorithms like A* to find the shortest path. A* is efficient because it uses a heuristic to guide the search towards the goal."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Sampling-Based Algorithms (e.g., RRT, PRM)"}),": For high-dimensional C-Spaces (robots with many joints), grid-based methods become computationally infeasible. Sampling-based planners like the ",(0,i.jsx)(e.strong,{children:"Probabilistic Roadmap (PRM)"})," and the ",(0,i.jsx)(e.strong,{children:"Rapidly-exploring Random Tree (RRT)"})," build a graph of reachable configurations by taking random samples from the C-Space. These methods are highly effective for complex problems."]}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"motion-planning",children:"Motion Planning"}),"\n",(0,i.jsxs)(e.p,{children:["While path planning finds a geometric path, ",(0,i.jsx)(e.strong,{children:"motion planning"})," also considers the robot's dynamics and constraints. It generates a full trajectory, which specifies the robot's position, velocity, and acceleration at every point in time along the path."]}),"\n",(0,i.jsx)(e.p,{children:'A trajectory is often generated by first finding a path, and then "smoothing" it and assigning a velocity profile (e.g., a trapezoidal velocity profile) to ensure the robot\'s velocity and acceleration limits are not exceeded.'}),"\n",(0,i.jsx)(e.h2,{id:"task-and-motion-planning-tamp",children:"Task and Motion Planning (TAMP)"}),"\n",(0,i.jsx)(e.p,{children:'For many real-world problems, the robot needs to perform not just one motion, but a sequence of actions that involve both movement and interaction with objects. For example, to "get the milk from the fridge," the robot must:'}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Navigate to the fridge."}),"\n",(0,i.jsx)(e.li,{children:"Open the fridge door."}),"\n",(0,i.jsx)(e.li,{children:"Move its arm to the milk carton."}),"\n",(0,i.jsx)(e.li,{children:"Grasp the milk."}),"\n",(0,i.jsx)(e.li,{children:"Move the milk out of the fridge."}),"\n",(0,i.jsx)(e.li,{children:"Close the fridge door."}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["This is the domain of ",(0,i.jsx)(e.strong,{children:"Task and Motion Planning (TAMP)"}),". TAMP is a challenging area of research that combines the high-level, symbolic reasoning of AI task planning with the low-level, geometric reasoning of motion planning."]}),"\n",(0,i.jsx)(e.p,{children:'The challenge lies in the fact that these two levels are tightly coupled: whether a high-level action (like "open the door") is possible depends on the robot\'s ability to find a valid motion plan for it. And the choice of which high-level action to take depends on the cost and feasibility of the resulting motions.'}),"\n",(0,i.jsx)(e.p,{children:"Modern TAMP solvers often work by iterating between a task planner that suggests a sequence of actions, and a motion planner that checks if those actions are feasible. This integration of symbolic and geometric reasoning is a key step towards creating more intelligent and capable robots."})]})}function d(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(c,{...n})}):c(n)}},8453:(n,e,o)=>{o.d(e,{R:()=>s,x:()=>r});var t=o(6540);const i={},a=t.createContext(i);function s(n){const e=t.useContext(a);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:s(n.components),t.createElement(a.Provider,{value:e},n.children)}}}]);